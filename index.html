<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>RPD &mdash; Introduction</title>
    <link href="./highlight-js.min.css" rel="stylesheet" type="text/css">
    <!-- load RPD library and requirements when document will be ready-->
    <link href="./rpd-docs.css" rel="stylesheet" type="text/css">
    <link href="./style.css" rel="stylesheet" type="text/css">
    <script defer src="./kefir.min.js"></script>
    <!-- compiled with: `gulp for-docs`-->
    <script defer src="./rpd-docs.min.js">       </script>
  </head>
  <body class="rpd-docs-introduction">
    <header id="_top"><img src="./rpd.svg" width="30px" height="30px">
      <h1><a href="./index.html">RPD &mdash; Reactive Patch Development</a></h1>
      <div id="version"><span>v2.0.0</span></div>
    </header>
    <nav>
      <ul>
        <li class="active"><a href="./index.html">Introduction</a>
          <ul>
            <li><a href="./index.html#what-is-rpd">What is RPD?</a></li>
            <li><a href="./index.html#features">Features</a></li>
            <li><a href="./index.html#code-examples">Code Examples</a></li>
            <li><a href="./index.html#terminology">Terminology</a></li>
          </ul>
        </li>
        <li><a href="./examples.html">Examples of RPD in Action</a>
          <ul>
          </ul>
        </li>
        <li><a href="./sections/setup.html">Getting Your Version of RPD</a>
          <ul>
            <li><a href="./sections/setup.html#download">Download</a></li>
            <li><a href="./sections/setup.html#setup">Setup</a></li>
            <li><a href="./sections/setup.html#compilation">Compilation</a></li>
          </ul>
        </li>
        <li><a href="./sections/network.html">Building a Patch Network</a>
          <ul>
            <li><a href="./sections/network.html#setup-rendering">Setup Rendering</a></li>
            <li><a href="./sections/network.html#creating-a-patch">Creating a Patch</a></li>
            <li><a href="./sections/network.html#adding-nodes">Adding Nodes</a></li>
            <li><a href="./sections/network.html#connecting-nodes">Connecting Nodes</a></li>
            <li><a href="./sections/network.html#sending-data">Sending Data</a></li>
            <li><a href="./sections/network.html#adding-sub-patches">Adding Subpatches</a></li>
            <li><a href="./sections/network.html#adding-import-export">Adding Import/Export</a></li>
          </ul>
        </li>
        <li><a href="./sections/api.html">API</a>
          <ul>
            <li><a href="./sections/api.html#rpd">Rpd</a></li>
            <li><a href="./sections/api.html#patch">Patch</a></li>
            <li><a href="./sections/api.html#node">Node</a></li>
            <li><a href="./sections/api.html#inlet">Inlet</a></li>
            <li><a href="./sections/api.html#outlet">Outlet</a></li>
            <li><a href="./sections/api.html#link">Link</a></li>
            <li><a href="./sections/api.html#modules">Modules</a></li>
          </ul>
        </li>
        <li><a href="./sections/toolkits.html">Creating Your Own Toolkits</a>
          <ul>
            <li><a href="./sections/toolkits.html#creating-toolkits">Organizational Moments</a></li>
            <li><a href="./sections/toolkits.html#defining-channel-type">Defining Channel Type</a></li>
            <li><a href="./sections/toolkits.html#defining-node-type">Defining Node Type</a></li>
            <li><a href="./sections/toolkits.html#writing-channel-renderer">Writing Channel Renderer</a></li>
            <li><a href="./sections/toolkits.html#writing-node-renderer">Writing Node Renderer</a></li>
            <li><a href="./sections/toolkits.html#writing-custom-i-o-module">Writing Custom I/O Module</a></li>
          </ul>
        </li>
        <li><a href="./sections/style.html">Custom Styling RPD</a>
          <ul>
            <li><a href="./sections/style.html#using-css-classes">Using CSS Classes</a></li>
            <li><a href="./sections/style.html#writing-your-own-renderer">Writing Your Own Renderer</a></li>
            <li><a href="./sections/style.html#writing-your-own-style">Writing Your Own Style</a></li>
          </ul>
        </li>
        <li><a href="./sections/events.html">Subscribing to Events</a>
          <ul>
            <li><a href="./sections/events.html#global-events">Global Events</a></li>
            <li><a href="./sections/events.html#network-events">Network Events</a></li>
            <li><a href="./sections/events.html#patch-events">Patch Events</a></li>
            <li><a href="./sections/events.html#node-events">Node Events</a></li>
            <li><a href="./sections/events.html#outlet-events">Outlet Events</a></li>
            <li><a href="./sections/events.html#inlet-events">Inlet Events</a></li>
            <li><a href="./sections/events.html#link-events">Link events</a></li>
          </ul>
        </li>
        <li><a href="./sections/participate.html">Participating in Development</a>
        </li>
      </ul>
    </nav>
    <main>
      <h2>Introduction </h2>
      <article><div id="logo-patch">
    <div id="patch-target"></div>
    <svg id="planets" width="500px" height="140px"></svg>
    <svg id="rpd-logo" width="140px" height="140px" viewBox="0 0 387 343" version="1.1"
     xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink">
    <title>rpd-logo</title>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <circle id="Oval-1" fill="#000000" cx="207" cy="172" r="165"/>
        <circle id="Oval-2" stroke="#FFFFFF" stroke-width="17" fill="#000000" cx="26.5" cy="172.5" r="28.5" />
        <path id="RPD-text" d="M -142.1018181,38.09454549999998 L -152.96727270000002,38.09454549999998 L -152.96727270000002,-66.63272750000002 L -117.09818130000001,-66.63272750000002 C -107.14904130000001,-66.63272750000002,-99.70911530000001,-64.38547650000002,-94.77818130000003,-59.89090950000002 C -89.84724830000002,-55.396341500000005,-87.38181830000002,-48.56731850000003,-87.38181830000002,-39.40363650000003 L -87.38181830000002,-31.549090500000005 C -87.38181830000002,-22.909047500000014,-89.38907030000001,-16.27638650000003,-93.40363630000002,-11.650909500000012 C -97.41820230000002,-7.025431500000025,-103.52723130000001,-4.320003500000013,-111.73090930000001,-3.5345455000000072 L -86.4654543,38.09454549999998 L -99.0327273,38.09454549999998 L -124.16727230000001,-3.403636500000033 L -142.1018181,-3.403636500000033 L -142.1018181,38.09454549999998 Z  M -142.1018181,-12.95999950000001 L -116.96727230000002,-12.95999950000001 C -110.24723930000002,-12.95999950000001,-105.44728730000003,-14.399985500000014,-102.56727230000001,-17.27999950000003 C -99.68725830000002,-20.160014500000017,-98.24727230000002,-24.872694500000023,-98.24727230000002,-31.41818150000003 L -98.24727230000002,-39.66545450000001 C -98.24727230000002,-45.687302500000015,-99.68725830000002,-50.050895500000024,-102.56727230000001,-52.75636350000002 C -105.44728730000003,-55.46183150000002,-110.24723930000002,-56.81454550000001,-116.96727230000002,-56.81454550000001 L -142.1018181,-56.81454550000001 L -142.1018181,-12.95999950000001 Z  M -66.30545430000001,38.09454549999998 L -66.30545430000001,-66.63272750000002 L -32.92363630000003,-66.63272750000002 C -22.79994930000001,-66.63272750000002,-15.360023300000023,-64.40729450000002,-10.603636300000005,-59.95636350000002 C -5.847249300000016,-55.50543250000001,-3.4690913000000023,-48.61095550000002,-3.4690913000000023,-39.27272750000003 L -3.4690913000000023,-27.490909500000015 C -3.4690913000000023,-18.15268050000003,-5.869067300000012,-11.192750500000017,-10.66909130000002,-6.6109095000000195 C -15.469115300000027,-2.029067500000025,-22.93085830000001,0.26181849999997553,-33.0545453,0.26181849999997553 L -55.44000030000001,0.26181849999997553 L -55.44000030000001,38.09454549999998 L -66.30545430000001,38.09454549999998 Z  M -55.44000030000001,-9.294545500000027 L -33.0545453,-9.294545500000027 C -26.24723830000002,-9.294545500000027,-21.40365030000001,-10.69089550000001,-18.52363630000002,-13.483636500000017 C -15.643622300000004,-16.276377500000024,-14.203636300000028,-20.814513500000032,-14.203636300000028,-27.09818150000001 L -14.203636300000028,-39.27272750000003 C -14.203636300000028,-45.46912150000003,-15.643622300000004,-49.94180450000002,-18.52363630000002,-52.69090950000003 C -21.40365030000001,-55.44001350000002,-26.24723830000002,-56.81454550000001,-33.0545453,-56.81454550000001 L -55.44000030000001,-56.81454550000001 L -55.44000030000001,-9.294545500000027 Z  M 15.356363699999974,38.09454549999998 L 15.356363699999974,-66.63272750000002 L 40.88363670000001,-66.63272750000002 C 52.05460169999998,-66.63272750000002,60.847240699999986,-63.27276050000002,67.26181869999999,-56.55272750000003 C 73.6763957,-49.832693500000005,76.88363670000001,-40.84369250000003,76.88363670000001,-29.585454500000026 L 76.88363670000001,1.5709094999999706 C 76.88363670000001,12.654600499999987,73.6763957,21.51269449999998,67.26181869999999,28.14545449999997 C 60.847240699999986,34.77821549999999,52.05460169999998,38.09454549999998,40.88363670000001,38.09454549999998 L 15.356363699999974,38.09454549999998 Z  M 26.22181869999997,28.276363499999974 L 41.14545469999996,28.276363499999974 C 49.43640469999997,28.276363499999974,55.65452469999997,25.832751499999972,59.7999997,20.945454499999983 C 63.945475699999974,16.058157499999993,66.01818170000001,9.81821949999997,66.01818170000001,2.2254544999999837 L 66.01818170000001,-30.23999950000001 C 66.01818170000001,-37.83276550000002,63.945475699999974,-44.15997450000003,59.7999997,-49.22181850000001 C 55.65452469999997,-54.28366150000002,49.43640469999997,-56.81454550000001,41.14545469999996,-56.81454550000001 L 26.22181869999997,-56.81454550000001 L 26.22181869999997,28.276363499999974 Z  M 136.60363669999998,-13.483636500000017 C 132.67634369999996,-13.483636500000017,129.4909217,-14.29090050000002,127.04727270000001,-15.905454500000019 C 124.60362470000001,-17.520008500000017,123.3818187,-20.203617500000007,123.3818187,-23.95636350000001 L 123.3818187,-29.454545500000023 C 123.3818187,-33.29456450000001,124.60362470000001,-36.06544550000001,127.04727270000001,-37.76727250000002 C 129.4909217,-39.46909950000003,132.67634369999996,-40.31999950000002,136.60363669999998,-40.31999950000002 C 140.5309287,-40.31999950000002,143.69453369999997,-39.46909950000003,146.09454569999997,-37.76727250000002 C 148.49455769999997,-36.06544550000001,149.6945457,-33.29456450000001,149.6945457,-29.454545500000023 L 149.6945457,-23.95636350000001 C 149.6945457,-20.203617500000007,148.45092169999998,-17.520008500000017,145.9636367,-15.905454500000019 C 143.4763517,-14.29090050000002,140.35638269999998,-13.483636500000017,136.60363669999998,-13.483636500000017 Z  M 118.5381817,66.63272749999999 L 129.6654547,14.400000499999976 L 152.96727269999997,14.400000499999976 L 128.2254547,66.63272749999999 L 118.5381817,66.63272749999999 Z" transform="translate(233.84363630000001 184.90545450000002)" fill="#FFFFFF" />
    </g>
</svg>

</div>

<!-- TODO SVG icon patch: -->
<!-- sun and moon -->
<!-- circle particles -->
<!-- logo color shift -->
<p>( <a href="https://github.com/shamansir/rpd">GitHub</a> | <a href="./examples.html">Examples</a> | <a href="./sections/api.html">API</a> | <a href="https://github.com/shamansir/rpd/issues">Issues</a> | <a href="#terminology">Terminology</a> <!-- | [Tests](...) --> )</p>
<h3 id="what-is-rpd-">What is RPD?</h3>
<p>RPD is the abbreviation for <em>Reactive Patch Development</em>...</p>
<p>...or, actually, whatever you decide. It is the library which brings node-based user interfaces to the modern web, in full their power (when you know how to use it) and in a very elegant and minimalistic way. <em>Node-based</em> is something like the thing you&#39;ll (probably) see above if you move your mouse cursor, or any other pointing device, above the RPD logo — (almost) nothing to do with <a href="https://nodejs.org">node.js</a>. Some people also say that with such user interfaces they do <em>Flow Programming</em>. If you are wondering yet, what that means, <em>Node-based</em> interface is the one where man may visually connect different low-level components using their inputs and outputs and observe the result in real time, take <!-- consider? --> <a href="https://puredata.info/">PureData</a>, <a href="quartzcomposer">QuartzComposer</a>, <a href="https://vvvv.org/">VVVV</a>, <a href="https://www.nodebox.net/">NodeBox</a>, <a href="https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/">Reaktor</a> etc. for example.</p>
<p>RPD brings DataFlow Programming to the Web both in the <em>elegant</em> and <em>minimal</em> ways.</p>
<!-- TODO: video or some example patch, processing patch from vimeo? -->
<p><em>Elegancy</em> is achieved both with providing you a very simple API for building these powerful things, and (thanks to the reactive streams, powered by <a href="https://rpominov.github.io/kefir/">Kefir.js library</a>) pure functional approach in the core, so it&#39;s easy for you to operate with sequences of data over time in any way you want, and also every action performed, (such as adding a node, or connecting something, or sending a value) is atomic, so it can easily be rolled back or stored in, and so restored from, some file.</p>
<!-- an example of defining simple node (and channel?) type and connecting it to a patch,
show streams and simple values -->
<p><em>Minimalism</em> is another goal of this library, which implies the RPD library size
is kept as minimal as possible, so your customer may load the interface you created using 3G internet or wi-fi limited to some very low speed. Don&#39;t ask me why may it happen, it still happens everywhere. Minimalism is here not in paranoid amounts, though&mdash;if feature requires a bit more code, or some task gets very complex with less code, we for sure will add some more code for the sake of simplicity.</p>
<p>The default configuration with SVG renderer and Quartz style included takes <em>11KB</em> when compiled, minimized and gzipped! (30KB not gzipped). Though you also need <a href="https://rpominov.github.io/kefir/">latest Kefir.js</a>, the only required dependency to make it work, which adds just ~10KB more, since <a href="https://rpominov.github.io">Kefir.js author</a> also likes minimalism in his code.</p>
<p>If you feel that&#39;s you know everything in this field and this library is definitely what you need (and no doubts, it is!), you may either download the <a href="./sections/setup.html#download">version with default configuration</a> or go straight to <a href="./sections/setup.html#compilation">Building Section</a> to discover how easy it is to grab a code and configure yourself a custom one. If you still feel unsafe, stay with me for a bit.</p>
<h3 id="features">Features</h3>
<ul>
<li>HTML (yes, pure HTML&amp;CSS!) and SVG renderers out-of-the-box;</li>
<li><a href="./sections/setup.html#styles-and-renderers">7 Rendering Styles</a> out-of-the-box;</li>
<li>Dozens of Nodes in 4 Toolkits, serving as examples of <a href="./sections/examples.html">what you can do</a> with the help of RPD;</li>
<li>Your user may <a href="./examples/sandbox.html">add Nodes from the list</a>, connect Nodes, remove Nodes, go into sub-Patches, ...;</li>
<li>Import/Export of Networks from/to JSON or Plain Text out-of-the-box;</li>
<li>Very powerful, and both super-simple and minimal, API allowing you to create your custom Node Toolkits;</li>
<li>Everything is configurable and optional at the same time, how you render the Node, the way it looks, the way it processes data, the way input and output channels behave;</li>
<li>Powered by <a href="https://rpominov.github.io/kefir/">Kefir</a> library, so allows you to include <em>Reactive Streams</em> of any complexity into the flow of your Network;</li>
<li><em>tons of features more...</em></li>
</ul>
<h3 id="code-examples">Code Examples</h3>
<p>All the examples below are <em>interactive</em>—you are free to connect Nodes and manipulate the Patch Flow.</p>
<p>To <strong>connect</strong> Outlet of one Node to Inlet of another, use the <em>click the Outlet</em> → <em>move your mouse</em> → <em>click the Inlet</em> method.</p>
<p><img src="./assets/rpd-connect.gif" width="320px" /></p>
<p>To <strong>disconnect</strong>, <em>click the Inlet</em> → <em>move your mouse</em> → <em>click anywhere</em>.</p>
<p><img src="./assets/rpd-disconnect.gif" width="320px" /></p>
<p>To <strong>reconnect</strong> to another Inlet: <em>click currently connected Inlet</em> → <em>move your mouse</em> → <em>click wanted Inlet</em>.</p>
<p><img src="./assets/rpd-reconnect.gif" width="320px" /></p>
<!--
> For the moment, it could be hard to connect Nodes using Touch control on a small screens or with high sensitivity setup, but [Touch Support is planned](https://github.com/shamansir/rpd/issues/368). -->
<p>Examples with source code:</p>
<ul>
<li><a href="#random-generator">Random Generator</a></li>
<li><a href="#flag-generator">Flag Generator</a></li>
<li><a href="#html5-canvas-and-custom-toolkit">HTML5 Canvas and Custom Toolkit</a></li>
</ul>
<h4 id="random-generator">Random Generator</h4>
<p>Random Generator with the help of <a href="https://github.com/shamansir/rpd/tree/master/src/toolkit/util"><code>util</code></a> toolkit. Following a signal of Metronome, which &quot;bangs&quot; every 3 seconds by default, Random Generator yields a new value between specified minimum and maximum (here: a number from 0 to 26, just for the sake of the example). The result then goes to a multiply-by-two Node, which is produced from a new type defined in the code. Then we Log last five generated random values and last five multiplied value, just to keep track on things.</p>
<div id="example-one"></div>

<pre><code class="lang-javascript">Rpd.renderNext(<span class="hljs-string">'svg'</span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'example-one'</span>),
               { style: <span class="hljs-string">'compact-v'</span> });

<span class="hljs-keyword">var</span> patch = Rpd.addPatch(<span class="hljs-string">'Generate Random Numbers'</span>).resizeCanvas(<span class="hljs-number">800</span>, <span class="hljs-number">110</span>);

<span class="hljs-comment">// add Metro Node, it may generate `bang` signal with the requested time interval</span>
<span class="hljs-keyword">var</span> metroNode = patch.addNode(<span class="hljs-string">'util/metro'</span>, <span class="hljs-string">'Metro'</span>).move(<span class="hljs-number">40</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">// add Random Generator Node that will generate random numbers on every `bang` signal</span>
<span class="hljs-keyword">var</span> randomGenNode = patch.addNode(<span class="hljs-string">'util/random'</span>, <span class="hljs-string">'Random'</span>).move(<span class="hljs-number">130</span>, <span class="hljs-number">20</span>);
randomGenNode.inlets[<span class="hljs-string">'max'</span>].receive(<span class="hljs-number">26</span>); <span class="hljs-comment">// set maximum value of the generated numbers</span>

<span class="hljs-comment">// add Log Node, which will log last results of the Random Generator Node</span>
<span class="hljs-keyword">var</span> logRandomNode = patch.addNode(<span class="hljs-string">'util/log'</span>, <span class="hljs-string">'Log'</span>).move(<span class="hljs-number">210</span>, <span class="hljs-number">60</span>);
randomGenNode.outlets[<span class="hljs-string">'out'</span>].connect(logRandomNode.inlets[<span class="hljs-string">'what'</span>]);

<span class="hljs-comment">// define the type of the node which multiplies the incoming value by two</span>
<span class="hljs-keyword">var</span> multiplyTwoNode = patch.addNode(<span class="hljs-string">'core/basic'</span>, <span class="hljs-string">'* 2'</span>, {
    process: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inlets</span>) </span>{
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'result'</span>: (inlets.multiplier || <span class="hljs-number">0</span>) * <span class="hljs-number">2</span>
        }
    }
}).move(<span class="hljs-number">240</span>, <span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> multiplierInlet = multiplyTwoNode.addInlet(<span class="hljs-string">'util/number'</span>, <span class="hljs-string">'multiplier'</span>);
<span class="hljs-keyword">var</span> resultOutlet = multiplyTwoNode.addOutlet(<span class="hljs-string">'util/number'</span>, <span class="hljs-string">'result'</span>);

<span class="hljs-comment">// connect Random Generator output to the multiplying node</span>
<span class="hljs-keyword">var</span> logMultiplyNode = patch.addNode(<span class="hljs-string">'util/log'</span>, <span class="hljs-string">'Log'</span>).move(<span class="hljs-number">370</span>, <span class="hljs-number">20</span>);
resultOutlet.connect(logMultiplyNode.inlets[<span class="hljs-string">'what'</span>]);

<span class="hljs-comment">// connect Random Generator output to the multiplying node</span>
randomGenNode.outlets[<span class="hljs-string">'out'</span>].connect(multiplierInlet);

<span class="hljs-comment">// finally connect Metro node to Random Generator, so the sequence starts</span>
metroNode.outlets[<span class="hljs-string">'out'</span>].connect(randomGenNode.inlets[<span class="hljs-string">'bang'</span>]);
</code></pre>
<h4 id="flag-generator">Flag Generator</h4>
<p>Tries to generate Country Flag from Unicode codepoints, <a href="https://bendodson.com/weblog/2016/04/26/emoji-flags-from-iso-3166-country-codes-in-swift">inspired by article &quot;Emoji flags from ISO 3166-1 country codes&quot;</a>. (There&#39;s also <a href="https://esham.io/2015/04/emoji-flags-redux">&quot;Emoji Flag Redux&quot;</a> article, written earlier). When you see blank squares (<em>tofu</em>) in &quot;Maybe Flag&quot; Node, there&#39;s no flag for this combination of letters.</p>
<p>Both Metronomes tick with different period—top one waits two seconds to pass between ticks, bottom one waits three. Ticks trigger corresponding Random Generators to generate a new value between 0 and 26 (so, 0 &lt;= value &lt; 26), which is used as an index of a letter in the alphabet to yield from Letter nodes. Then, two letters are sent to <code>Maybe&lt;Flag&gt;</code> Node where they are combined, and if they form a proper two-letter ISO code of the country, you see the flag. If not, you see two <em>tofu</em> squares or a squares with letters inside. Or, if your system is not supporting Emoji, you see something else and then for you this one is not the kind of representative example.</p>
<div id="example-two"></div>

<pre><code class="lang-javascript">Rpd.renderNext(<span class="hljs-string">'svg'</span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'example-two'</span>),
                      { style: <span class="hljs-string">'compact-v'</span> });

<span class="hljs-keyword">var</span> patch = Rpd.addPatch(<span class="hljs-string">'Flag Generator'</span>).resizeCanvas(<span class="hljs-number">800</span>, <span class="hljs-number">200</span>);

<span class="hljs-keyword">var</span> metro1 = patch.addNode(<span class="hljs-string">'util/metro'</span>).move(<span class="hljs-number">50</span>, <span class="hljs-number">30</span>);
<span class="hljs-keyword">var</span> metro2 = patch.addNode(<span class="hljs-string">'util/metro'</span>).move(<span class="hljs-number">50</span>, <span class="hljs-number">90</span>);
metro1.inlets[<span class="hljs-string">'period'</span>].receive(<span class="hljs-number">2000</span>);
metro2.inlets[<span class="hljs-string">'period'</span>].receive(<span class="hljs-number">3000</span>);

<span class="hljs-keyword">var</span> random1 = patch.addNode(<span class="hljs-string">'util/random'</span>).move(<span class="hljs-number">170</span>, <span class="hljs-number">10</span>);
random1.inlets[<span class="hljs-string">'max'</span>].receive(<span class="hljs-number">26</span>);
<span class="hljs-keyword">var</span> random2 = patch.addNode(<span class="hljs-string">'util/random'</span>).move(<span class="hljs-number">170</span>, <span class="hljs-number">120</span>);
random2.inlets[<span class="hljs-string">'max'</span>].receive(<span class="hljs-number">26</span>);

<span class="hljs-keyword">var</span> letter1 = patch.addNode(<span class="hljs-string">'util/letter'</span>).move(<span class="hljs-number">300</span>, <span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> letter2 = patch.addNode(<span class="hljs-string">'util/letter'</span>).move(<span class="hljs-number">300</span>, <span class="hljs-number">110</span>);

metro1.outlets[<span class="hljs-string">'bang'</span>].connect(random1.inlets[<span class="hljs-string">'bang'</span>]);
metro2.outlets[<span class="hljs-string">'bang'</span>].connect(random2.inlets[<span class="hljs-string">'bang'</span>]);

random1.outlets[<span class="hljs-string">'random'</span>].connect(letter1.inlets[<span class="hljs-string">'code'</span>]);
random2.outlets[<span class="hljs-string">'random'</span>].connect(letter2.inlets[<span class="hljs-string">'code'</span>]);

Rpd.nodetype(<span class="hljs-string">'user/maybe-flag'</span>, {
    title: <span class="hljs-string">'May be a flag?'</span>,
    inlets: {
        <span class="hljs-string">'letterA'</span>: { type: <span class="hljs-string">'core/any'</span> },
        <span class="hljs-string">'letterB'</span>: { type: <span class="hljs-string">'core/any'</span> }
    },
    outlets: {
        <span class="hljs-string">'char'</span>: { type: <span class="hljs-string">'core/any'</span> },
        <span class="hljs-string">'code'</span>: { type: <span class="hljs-string">'core/any'</span> }
    },
    process: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inlets</span>) </span>{
        <span class="hljs-keyword">if</span> (!inlets.letterA || !inlets.letterB) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">return</span> { <span class="hljs-string">'code'</span>: <span class="hljs-built_in">String</span>.fromCharCode(inlets.letterA.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">32</span>)
                       + <span class="hljs-built_in">String</span>.fromCharCode(inlets.letterB.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">32</span>),
                 <span class="hljs-string">'char'</span> : fromCodePoint(<span class="hljs-number">55356</span>)
                        + fromCodePoint(inlets.letterA.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">97</span> + <span class="hljs-number">56806</span>)
                        + fromCodePoint(<span class="hljs-number">55356</span>)
                        + fromCodePoint(inlets.letterB.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">97</span> + <span class="hljs-number">56806</span>) };
    }
});

<span class="hljs-comment">// d3_tiny is a 100-lined JavaScript included in RPD distribution</span>
<span class="hljs-comment">// which supports basic d3.js functions like `.select`, `.attr` &amp; s.o.,</span>
<span class="hljs-comment">// fully compatible with "big" d3.js</span>
<span class="hljs-keyword">var</span> d3 = d3 || d3_tiny;

Rpd.noderenderer(<span class="hljs-string">'user/maybe-flag'</span>, <span class="hljs-string">'svg'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> textElm;
    <span class="hljs-keyword">return</span> {
        first: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyElm</span>) </span>{
            textElm = d3.select(bodyElm).append(<span class="hljs-string">'text'</span>)
                        .style(<span class="hljs-string">'text-anchor'</span>, <span class="hljs-string">'middle'</span>);
        },
        always: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyElm, inlets, outlets</span>) </span>{
            <span class="hljs-keyword">if</span> (!outlets) <span class="hljs-keyword">return</span>;
            textElm.text(outlets.char + <span class="hljs-string">' ('</span> + outlets.code + <span class="hljs-string">')'</span>);
        }
    }
});

<span class="hljs-keyword">var</span> maybeFlag = patch.addNode(<span class="hljs-string">'user/maybe-flag'</span>, <span class="hljs-string">'Maybe&lt;Flag&gt;'</span>).move(<span class="hljs-number">430</span>, <span class="hljs-number">70</span>);
letter1.outlets[<span class="hljs-string">'letter'</span>].connect(maybeFlag.inlets[<span class="hljs-string">'letterA'</span>]);
letter2.outlets[<span class="hljs-string">'letter'</span>].connect(maybeFlag.inlets[<span class="hljs-string">'letterB'</span>]);

<span class="hljs-keyword">var</span> logNode = patch.addNode(<span class="hljs-string">'util/log'</span>, {}, {
    <span class="hljs-string">'svg'</span>: {
        size: { width: <span class="hljs-number">210</span>, height: <span class="hljs-number">30</span> }
    }
}).move(<span class="hljs-number">550</span>, <span class="hljs-number">70</span>);
maybeFlag.outlets[<span class="hljs-string">'char'</span>].connect(logNode.inlets[<span class="hljs-string">'what'</span>]);
</code></pre>
<h4 id="html5-canvas-and-custom-toolkit">HTML5 Canvas and Custom Toolkit</h4>
<p>The Scene consists of seven (by default) shifted and colored squares is loaded and attached to HTML5 Canvas. It has a configuration object where values could be changed by user. Since it uses <code>requestAnimationFrame</code> for animation, on every frame it checks this configuration and redraws itself according to values specified there. So when values in this object are changed, Scene is immediately updated.</p>
<p>The Networks of given Nodes allows you to change configuration values. For example, by tuning the top left Knob, you may change the value of Red component of the starting color. By tuning the one in the middle, you may change the Y-coordinate of the shift between every two squares. You may take one of the free unconnected Knobs and connect it to Count Inlet of the Scene node to control the number of squares.</p>
<p>But if you connect the <code>result</code> Outlet of the Node named <code>%</code> to one or several of the <code>color</code> Node Inlets, you may interact with the Scene in even more direct way. <code>mouse</code> Node collects all of the movements of your mouse and converts them to the pair of X and Y coordinates. Then the mentioned <code>%</code> Node divides the value of X coordinate by modulus of 256, so the result is always between 0 and 256 (so, 0 &lt;= result &lt; 256) and always matches the amount <code>color</code> node wants as the input.</p>
<div id="example-three"></div>

<pre><code class="lang-javascript"><span class="hljs-comment">/* ============== Coordinates Channel Type ============== */</span>

Rpd.channeltype(<span class="hljs-string">'my/coords'</span>, {
  show: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-comment">// nicely show a received pair of coordinates, floored to an integer</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;'</span> + <span class="hljs-built_in">Math</span>.floor(val.x) + <span class="hljs-string">':'</span> + <span class="hljs-built_in">Math</span>.floor(val.y) + <span class="hljs-string">'&gt;'</span>;
  }
});

<span class="hljs-comment">/* ============== Coordinates Node Type ============== */</span>

Rpd.nodetype(<span class="hljs-string">'my/coords'</span>, {
  inlets: {
    x: { type: <span class="hljs-string">'util/number'</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> },
    y: { type: <span class="hljs-string">'util/number'</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> }
  },
  outlets: {
    out: { type: <span class="hljs-string">'my/coords'</span> }
  },
  <span class="hljs-comment">// joins received `x` and `y` into one object</span>
  process: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inlets</span>) </span>{
    <span class="hljs-keyword">return</span> { out: { x: inlets.x, y: inlets.y } };
  }
});

<span class="hljs-comment">//* ============== Angle (radians) Channel Type ============== */</span>

Rpd.channeltype(<span class="hljs-string">'my/angle'</span>, {
  allow: [ <span class="hljs-string">'util/number '</span>], <span class="hljs-comment">// outlets of `util/number` type are allowed to be</span>
                            <span class="hljs-comment">// connected to inlets of `my/angle` type</span>
  accept: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">return</span> (v &gt;= <span class="hljs-number">0</span>) &amp;&amp; (v &lt;= <span class="hljs-number">360</span>); },
  show: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">return</span> v + <span class="hljs-string">'˚'</span>; }
});

<span class="hljs-comment">/* ============== Canvas-driven Scene Node Type ============== */</span>

<span class="hljs-keyword">var</span> defaultConfig = {
  count: <span class="hljs-number">7</span>,
  <span class="hljs-keyword">from</span>: { r: <span class="hljs-number">0</span>, g: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span> },
  to: { r: <span class="hljs-number">255</span>, g: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span> },
  shift: { x: <span class="hljs-number">25</span>, y: <span class="hljs-number">0</span> },
  rotate: <span class="hljs-number">15</span>
};

Rpd.nodetype(<span class="hljs-string">'my/scene'</span>, {
  inlets: {
    <span class="hljs-keyword">from</span>: { type: <span class="hljs-string">'util/color'</span>, <span class="hljs-string">'default'</span>: defaultConfig.from },
    to: { type: <span class="hljs-string">'util/color'</span>, <span class="hljs-string">'default'</span>: defaultConfig.to },
    count: { type: <span class="hljs-string">'util/number'</span>, <span class="hljs-string">'default'</span>: defaultConfig.count,
             adapt: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(v); } },
    shift: { type: <span class="hljs-string">'my/coords'</span>, <span class="hljs-string">'default'</span>: defaultConfig.shift },
    rotate: { type: <span class="hljs-string">'my/angle'</span>, <span class="hljs-string">'default'</span>: defaultConfig.rotate },
  },
  process: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}
});

<span class="hljs-comment">/* ============== Renderer for Canvas-driven Scene ============== */</span>

<span class="hljs-keyword">var</span> SVG_XMLNS = <span class="hljs-string">'https://www.w3.org/2000/svg'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lerp</span>(<span class="hljs-params">v1, v2, pos</span>) </span>{
  <span class="hljs-keyword">return</span> (v1 + ((v2 - v1) * pos));
}

Rpd.noderenderer(<span class="hljs-string">'my/scene'</span>, <span class="hljs-string">'svg'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> width = <span class="hljs-number">100</span>, height = <span class="hljs-number">100</span>;

  <span class="hljs-keyword">var</span> context;
  <span class="hljs-keyword">var</span> particles = [];
  <span class="hljs-keyword">var</span> lastCount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> config = defaultConfig;

  <span class="hljs-comment">// function to render current state of the scene using requestAnimationFrame</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (context) {
      context.save();
      context.fillStyle = <span class="hljs-string">'#fff'</span>;
      context.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);
      context.fillStyle = <span class="hljs-string">'#000'</span>;
      particles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">particle, i</span>) </span>{
        context.fillStyle = <span class="hljs-string">'rgb('</span> +
          <span class="hljs-built_in">Math</span>.floor(lerp(config.from.r, config.to.r,
                          <span class="hljs-number">1</span> / (particles.length - <span class="hljs-number">1</span>) * i)) + <span class="hljs-string">','</span> +
          <span class="hljs-built_in">Math</span>.floor(lerp(config.from.g, config.to.g,
                          <span class="hljs-number">1</span> / (particles.length - <span class="hljs-number">1</span>) * i)) + <span class="hljs-string">','</span> +
          <span class="hljs-built_in">Math</span>.floor(lerp(config.from.b, config.to.b,
                          <span class="hljs-number">1</span> / (particles.length - <span class="hljs-number">1</span>) * i)) + <span class="hljs-string">')'</span>;
        context.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>);
        context.translate(config.shift.x, config.shift.y);
        context.rotate(config.rotate * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>);
      });
      context.restore();
    }
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  <span class="hljs-comment">// return actual renderer definition</span>
  <span class="hljs-keyword">return</span> {
    size: { width: width + <span class="hljs-number">10</span>, height: height + <span class="hljs-number">10</span> },
    pivot: { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> },

    <span class="hljs-comment">// on creation, add canvas to the node body</span>
    first: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyElm</span>) </span>{
      <span class="hljs-keyword">var</span> group = <span class="hljs-built_in">document</span>.createElementNS(SVG_XMLNS, <span class="hljs-string">'g'</span>);
      group.setAttributeNS(<span class="hljs-literal">null</span>, <span class="hljs-string">'transform'</span>, <span class="hljs-string">'translate(5, 5)'</span>);
      <span class="hljs-keyword">var</span> foreign = <span class="hljs-built_in">document</span>.createElementNS(SVG_XMLNS, <span class="hljs-string">'foreignObject'</span>);
      canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);
      canvas.setAttributeNS(<span class="hljs-literal">null</span>, <span class="hljs-string">'width'</span>, width + <span class="hljs-string">'px'</span>);
      canvas.setAttributeNS(<span class="hljs-literal">null</span>, <span class="hljs-string">'height'</span>, height + <span class="hljs-string">'px'</span>);
      canvas.style.position = <span class="hljs-string">'fixed'</span>;
      foreign.appendChild(canvas);
      group.appendChild(foreign);
      bodyElm.appendChild(group);

      context = canvas.getContext(<span class="hljs-string">'2d'</span>);
    },

    <span class="hljs-comment">// update config values using values from inlets</span>
    always: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bodyElm, inlets</span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(inlets.count) &amp;&amp; (inlets.count != lastCount)) {
        particles = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; inlets.count; i++) {
          particles.push({});
        }
        lastCount = inlets.count;
      }
      <span class="hljs-keyword">if</span> (inlets.from) config.from = inlets.from;
      <span class="hljs-keyword">if</span> (inlets.to) config.to = inlets.to;
      <span class="hljs-keyword">if</span> (inlets.shift) config.shift = inlets.shift;
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(inlets.rotate)) config.rotate = inlets.rotate;
    }

  };
});

<span class="hljs-comment">/* ============== Patch Structure ============== */</span>

Rpd.renderNext(<span class="hljs-string">'svg'</span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'example-three'</span>),
                      { style: <span class="hljs-string">'compact-v'</span> });

<span class="hljs-keyword">var</span> patch = Rpd.addPatch(<span class="hljs-string">'Generate Canvas Shapes'</span>).resizeCanvas(<span class="hljs-number">800</span>, <span class="hljs-number">205</span>);

<span class="hljs-keyword">var</span> scene = patch.addNode(<span class="hljs-string">'my/scene'</span>).move(<span class="hljs-number">570</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">var</span> color1 = patch.addNode(<span class="hljs-string">'util/color'</span>).move(<span class="hljs-number">120</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">var</span> color2 = patch.addNode(<span class="hljs-string">'util/color'</span>).move(<span class="hljs-number">100</span>, <span class="hljs-number">80</span>);
<span class="hljs-keyword">var</span> coords = patch.addNode(<span class="hljs-string">'my/coords'</span>).move(<span class="hljs-number">305</span>, <span class="hljs-number">90</span>);
<span class="hljs-keyword">var</span> knob1 = patch.addNode(<span class="hljs-string">'util/knob'</span>).move(<span class="hljs-number">25</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">var</span> knob2 = patch.addNode(<span class="hljs-string">'util/knob'</span>).move(<span class="hljs-number">490</span>, <span class="hljs-number">110</span>);
<span class="hljs-keyword">var</span> knob3 = patch.addNode(<span class="hljs-string">'util/knob'</span>).move(<span class="hljs-number">210</span>, <span class="hljs-number">105</span>);
<span class="hljs-keyword">var</span> knob4 = patch.addNode(<span class="hljs-string">'util/knob'</span>).move(<span class="hljs-number">400</span>, <span class="hljs-number">110</span>);
<span class="hljs-keyword">var</span> mouse = patch.addNode(<span class="hljs-string">'util/mouse-pos'</span>).move(<span class="hljs-number">0</span>, <span class="hljs-number">70</span>);
<span class="hljs-keyword">var</span> modulus = patch.addNode(<span class="hljs-string">'util/mod'</span>).move(<span class="hljs-number">20</span>, <span class="hljs-number">150</span>);
<span class="hljs-keyword">var</span> comment = patch.addNode(<span class="hljs-string">'util/comment'</span>).move(<span class="hljs-number">80</span>, <span class="hljs-number">100</span>);

knob1.inlets[<span class="hljs-string">'max'</span>].receive(<span class="hljs-number">256</span>);
knob2.inlets[<span class="hljs-string">'max'</span>].receive(<span class="hljs-number">180</span>);
knob4.inlets[<span class="hljs-string">'max'</span>].receive(<span class="hljs-number">15</span>);
coords.inlets[<span class="hljs-string">'x'</span>].receive(<span class="hljs-number">25</span>);
modulus.inlets[<span class="hljs-string">'b'</span>].receive(<span class="hljs-number">256</span>);
comment.inlets[<span class="hljs-string">'text'</span>].receive(<span class="hljs-string">'Try to connect "%" node output'</span> +
    + <span class="hljs-string">' to inlet of "my/coords" node or one of the "color" nodes'</span>);

knob1.outlets[<span class="hljs-string">'number'</span>].connect(color1.inlets[<span class="hljs-string">'r'</span>]);
knob3.outlets[<span class="hljs-string">'number'</span>].connect(coords.inlets[<span class="hljs-string">'y'</span>]);
color1.outlets[<span class="hljs-string">'color'</span>].connect(scene.inlets[<span class="hljs-string">'from'</span>]);
color2.outlets[<span class="hljs-string">'color'</span>].connect(scene.inlets[<span class="hljs-string">'to'</span>]);
coords.outlets[<span class="hljs-string">'out'</span>].connect(scene.inlets[<span class="hljs-string">'shift'</span>]);
mouse.outlets[<span class="hljs-string">'x'</span>].connect(modulus.inlets[<span class="hljs-string">'a'</span>]);
</code></pre>
<h3 id="terminology">Terminology</h3>
<p>At first, we&#39;ll define terms of node-based interfaces, the way RPD sees them, starting from the highest level (the <em>Network</em>) and going down till the lowest known level (the <em>Link</em>). If that&#39;s not very comfortable for you, you may do it in reverse direction, then please scroll down to <em>Link</em> and then reach the top at <em>Network</em>.</p>
<!-- TODO Image or interactive example (jsfiddle, run by click?) showing the network of simple patches -->
<h4 id="network">Network</h4>
<p><img src="./assets/rpd-network.png" width="600px" alt="Network"></img></p>
<p><em>Network</em> defines a system of Patches. At this level Patch may be considered as a complex procedure with several inputs and outputs and a Network is a program that uses these procedures.</p>
<p>Say, you define some complex functionality of a 3D vertex shader with a Patch. It has its inputs such as 3D position, color and texture coordinate of a vertex and outputs as 2D coordinate and modified color. Then you may create another “root” Patch, which allows user to apply combinations of different vertex shaders to an imported object and so re-use the Shader Patch several times in different configurations. These two Patches (first one used several times and second one used once) form a simple Network.</p>
<!-- TODO: diagram of a vertex shader network -->
<p>So, some Node in one Patch may represent the inputs and outputs of another Patch&#39;s copy, running in the same Network.</p>
<h4 id="patch">Patch</h4>
<p><img src="./assets/patch-no-frame.png" width="440px" alt="Patch"></img></p>
<p><em>Patch</em> stores a collection of Node instances and connections between them.
The resulting structure of Nodes and connections defines the way data flows in this Patch.</p>
<!--TODO Two nodes connected, to show inlets and outlets (run by click?) -->
<h4 id="node">Node</h4>
<p><img src="./assets/node-no-frame.png" width="160px" alt="Node"></img></p>
<p><em>Nodes</em> are building blocks which use connections to receive any data from one nodes, modify it, and send transformed data to another Nodes. Nodes may have zero or more inputs of different types, named <em>Inlets</em> and zero or more outputs of different types, named <em>Outlets</em>. Nodes may have a body which may represent received data or even have some controls allowing user to change it though hidden inlets.</p>
<h4 id="outlet">Outlet</h4>
<p><img src="./assets/outlets.png" width="160px" alt="Outlets"></img></p>
<p><em>Outlet</em> is a socket of a Node designed to send outgoing data. Outlet may be connected to an Inlet of another Node or to several Inlets of other Nodes.</p>
<p>Type of the Outlet determines which types of values it sends.</p>
<p>Outlet and Inlet types are called Channel Types.</p>
<h4 id="inlet">Inlet</h4>
<p><img src="./assets/inlets.png" width="160px" alt="Inlets"></img></p>
<p><em>Inlet</em> is a socket of a Node designed to receive incoming data. Depending on configuration, it may accept only one connection from an Outlet or any number of connections from several Outlets.</p>
<p>Inlet may have a default value, so it sends it to the Node when the latter is added to a Patch.</p>
<p>Inlet may be hidden, so it won&#39;t be visible for user, but may receive data from inputs located in the body of the Node.</p>
<p>Inlet may be “cold”, in contrary to “hot” by default, so it won&#39;t trigger the modifying process, but save the last value that came to this Inlet.</p>
<p>Inlets may accept or deny values depending on their type. Type may specify a function which will transform data before it will be sent to the Node.</p>
<h4 id="link">Link</h4>
<p><img src="./assets/link-no-frame.png" width="100px" alt="Link"></img></p>
<p><em>Link</em> is what connects single Outlet to single Inlet. Always one to one. It may be disabled, so it will not deliver all the data which comes inside, but keep the connection.</p>
<!-- TODO Nodes from different toolkits -->
<h4 id="toolkit">Toolkit</h4>
<p><em>Toolkit</em> is a group of Node and Channel Types lying in (preferrably, but not required) one namespace. For example, <a href="https://p5js.org">Processing.js</a> Toolkit may define Nodes and Channels which control the configuration of a Processing Sketch, use and convert data types specific to Processing and so on.</p>
<!-- TODO SVG and HTML -->
<h4 id="rendering-flow">Rendering Flow</h4>
<p><img src="./assets/render-flow.png" width="800px" alt="Render Flow"></img></p>
<p>This sub-section is actually not about a specific Term and intended to quickly clarify how the things described below work together.</p>
<p>When you need to render a Patch, you need to know three things: which Renderer you want to use, which Style you prefer visually and the Target where you want everything to be injected. Style is optional, though, since <code>quartz</code> is the default one to be used, but sad things happen, and you may dislike it. So, to satisfy every taste, several Styles are included in RPD distribution. You actually may use same configuration to render several Patches, but let&#39;s leave it to <a href="./api.html">API docs</a> for now.</p>
<p>The engine of the rendering process is Actions. They are fired on every change of the value, when new Connection between Outlet and Inlet is established, or instead someone removed the Connection, or someone moved one Node etc. To the Rendering System there is no matter who did this Action, User or API call.</p>
<blockquote>
<p>If you know what <a href="https://facebook.github.io/flux/">Flux</a> or <a href="https://elm-lang.org/">Elm</a> is, it is almost the same Action concept you&#39;ve met there; if you don&#39;t know about both, just replace Action term with Event term here and below.</p>
</blockquote>
<p>So, for example you chose <code>&#39;svg&#39;</code> Renderer to render your Patch. What happens then? On every user or logical Action, this Renderer is notified. Then this Renderer decides which (preferably, the tiniest one) part of the Network it should re-render. If Node or Channel (Inlet or Outlet) is required to be updated, it searches for the corresponding Node Renderer or Channel Renderer, the one assigned to this Renderer. Node/Channel Renderer can render particular type of the Node/Channel (and then it&#39;s called Node/Channel Type Renderer) or it may be overridden for the specific instance of the Node/Channel (and then it&#39;s called Node/Channel Instance Renderer). If something else was updated, Renderer re-renders this part itself, without delegation. No, actually, it sometimes passes some updates to Style, just Node/Channel Renderer step is skipped in this case.</p>
<p>In its turn, Node/Channel Renderer renders the body of the Node (<code>&#39;svg&#39;</code> Renderer uses SVG elements for that) or a value of the Channel (same, with SVG elements). Then the result of the rendering is injected into a structure, provided by selected Style.</p>
<p>And the final piece of DOM (or whatever) is injected into the Target, into a proper place. Target for <code>&#39;html&#39;</code> Renderer should be some HTML element like <code>&lt;div /&gt;</code>, for <code>&#39;svg&#39;</code> Renderer it should be some SVG element, preferably <code>&lt;svg&gt;</code> or <code>&lt;g /&gt;</code>, and so on.</p>
<p>That&#39;s it, now users sees the whole thing in dynamic.</p>
<p>Now, let&#39;s describe the same process from participants&#39; points of view.</p>
<h4 id="renderer">Renderer</h4>
<p><img src="./assets/renderer.png" width="100px" alt="Renderer"></img></p>
<p><em>Renderer</em> is a system which determines the way current Patch model is rendered. For now, there are two Renderers: HTML and SVG, they render Patches to HTML or SVG tags correspondingly. For instance, HTML Renderer renders Link connections as <code>span</code> blocks with CSS borders and SVG Renderers just draws SVG <code>line</code> tags for the same purpose.</p>
<p>Also, Renderer determines where new node will be placed if position was not specified.</p>
<h4 id="node-type-instance-renderer">Node Type/Instance Renderer</h4>
<p><img src="./assets/instance-renderer.png" width="200px" alt="Node Instance Renderer"></img></p>
<p><em>Node Type Renderer</em> builds the body of the Node and may update its content when some incoming update triggered it. Also, it may send values from inner controls to a hidden Inlets of the Node.</p>
<p>There should be a separate Node Type Renderer for each way to render a node, such as HTML, SVG and so on. By default, if Node can&#39;t render itself in the requested way, it is rendered as an empty Node, yet having all the defined Inlets and Outlets.</p>
<p><em>Node Instance Renderer</em> has exactly the same definition structure, it just overrides the Node Type Renderer so you can render any specific Node instance completely another way with just re-defining Type Renderer inline.</p>
<h4 id="channel-type-instance-renderer">Channel Type/Instance Renderer</h4>
<p><img src="./assets/instance-renderer.png" width="200px" alt="Channel Instance Renderer"></img></p>
<p><em>Channel Type Renderer</em> builds the Inlet/Outlet value representation and also may add the editor to a Channel value.</p>
<p>Editor is an optional control which lets user override the value in the Inlet.</p>
<p><em>NB: For the moment, value editors are only supported in HTML Renderer</em></p>
<p><em>Channel Instance Renderer</em> has exactly the same definition structure, it just overrides the Channel Type Renderer so you can render any specific Channel instance completely another way with just re-defining Type Renderer inline.</p>
<h4 id="style">Style</h4>
<p><img src="./assets/style.png" width="200px" alt="Style"></img></p>
<p><em>Style</em> determines the look of the Patch, Node, Channel or a Link. While Renderer builds the outer structure, controls drag-n-drop and other logic, Style only determines the inner visual appearance of these elements.</p>
<h4 id="canvas">Canvas</h4>
<p><em>Canvas</em> is a place where Patch is rendered and operated. It has size and could have background color, for example. When several Patches share same target DOM element, they still have different canvases. Canvas could be an HTML5 Canvas by accident, but for sure not obligatory — this term came from <a href="https://puredata.info/">Pure Data</a>, the thing existed long before HTML5 and appeared just few years after first ever HTML specification.</p>
<h4 id="projection">Projection</h4>
<div class="in-progress" text="In Progress."><span>[ In Progress ]</span></div>
<h4 id="module">Module</h4>
<p><em>Module</em> is any extension for the RPD functionality, not included in the library code itself.</p>
<p>For example, <em>I/O Module</em> records every action (or only some of the actions) performed to build the Network in some specific format, so it can optionally “replay” these actions later, in proper order.</p>
<script defer src="./d3.v3.min.js"></script>
<script defer src="./docs-patch.js"></script>
<script defer src="./index-patches.js"></script>

      </article>
      <div id="jump-to-top"><a href="#_top">↑</a></div>
    </main>
    <footer><span>&copy; shaman.sir, 2016</span></footer>
  </body>
</html>